-- Basic Metamodel Syntax Version
bmm_version = <"2.1">

-- ----------------------------------
-- schema identification
-- (schema_id computed as <rm_publisher>_<schema_name>_<rm_release>)
-- ----------------------------------
rm_publisher = <"CIMI">
schema_name = <"RM_CORE">
rm_release = <"0.0.4">

-- ----------------------------------
-- schema documentation
-- ----------------------------------
schema_revision = <"Sat Dec 02 12:42:59 PST 2017">
schema_lifecycle_state = <"ForComment">
schema_description = <"CIMI_RM_CORE.v0.0.4.mdzip - Schema generated from UML">


-- ----------------------------------
-- archetyping
-- ----------------------------------
archetype_rm_closure_packages = <"CIMI_Reference_Model.Core", "CIMI_Reference_Model.DataType", "CIMI_Reference_Model.Primitive_Types">
packages = <
	["CIMI_Reference_Model"] = <
		name = <"CIMI_Reference_Model">
		packages = <
			["Core"] = <
				name = <"Core">
				classes = <"Archetyped", "Locatable">
			>
			["DataType"] = <
				name = <"DataType">
				classes = <"NumericalValue", "CodedText", "Integer", "DataType", "Date", "TemporalValue", "Duration", "EmbeddedContent", "IntervalValue", "Multimedia", "OrdinalConcept", "ParsableContent", "PlainText", "OrderedValue", "Quantity", "TermMapping", "Text", "Time", "Uri", "Instant", "PositiveInteger", "UnsignedInteger", "Ratio", "Concept", "CodeSystem", "GpsLocation", "DateTime", "Decimal">
			>
			["Primitive_Types"] = <
				name = <"Primitive_Types">
				classes = <"Any", "Array", "List", "Boolean", "Byte", "Character", "Integer", "Real", "String", "URI">
			>
		>
	>
>
class_definitions = <
	["Archetyped"] = <
		documentation = <"Archetypes act as the configuration basis for the particular structures of instances defined by the reference model. To enable archetypes to be used to create valid data, key classes in the reference model act as root points for archetyping; accordingly, these classes have the archetype_details attribute set.

An instance of the class ARCHETYPED contains the relevant archetype identification information, allowing generating archetypes to be matched up with data instances.">
		name = <"Archetyped">
		properties = <
			["archetype_id"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Globally unique archetype identifier.">
				name = <"archetype_id">
				type = <"String">
				is_mandatory = <True>
			>
			["rm_version"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Version of the CIMI reference model used to create this object. Expressed in terms of the release version string, e.g. 1.0 , 1.2.4 .">
				name = <"rm_version">
				type = <"String">
				is_mandatory = <True>
			>
		>
	>
	["Locatable"] = <
		documentation = <"Most classes in the CIMI reference model inherit from the LOCATABLE class, which defines the idea of 'locatability in an archetyped structure'. LOCATABLE defines a runtime name and an archetype_node_id. The archetype_node_id is the standardised semantic code for a node and comes from the corresponding node in the archetype used to create the data. The only exception is at archetype root points in data, where archetype_node_id carries the archetype identifier in string form rather than an interior node id from an archetype. LOCATABLE also provides the attribute archetype_details, which is non-Void for archetype root points in data, and carries meta-data relevant to root points. The name attribute carries a name created at runtime. The 'meaning' of any node is derived formally from the archetype by obtaining the text value for the archetype_node_id code from the archetype ontology section, in the language required.">
		name = <"Locatable">
		properties = <
			["archetype_node_id"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The standardised semantic code for a node and comes from the corresponding node in the archetype used to create the data. The only exception is at archetype root points in data, where archetype_node_id carries the archetype identifier in string form rather than an interior node id from an archetype. ">
				name = <"archetype_node_id">
				type = <"String">
				is_mandatory = <True>
			>
			["name"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"A name created at runtime">
				name = <"name">
				type = <"String">
				is_mandatory = <True>
			>
			["archetype_details"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"LOCATABLE also provides the attribute Archetype_details, which is non-Void for archetype root points in data, and carries meta-data relevant to root points. ">
				name = <"archetype_details">
				type = <"Archetyped">
			>
		>
	>
	["NumericalValue"] = <
		documentation = <"Abstract class defining the concept of relative quantified amounts. For relative quantities, the +' and -' operators are defined.">
		name = <"NumericalValue">
		ancestors = <"OrderedValue",...>
		properties = <
			["precision"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"precision">
				type = <"Integer">
			>
		>
	>
	["CodedText"] = <
		documentation = <"A text item whose value must be the rubric from a controlled terminology, the key (i.e. the code') of which is the code attribute. In other words: a CODED_TEXT is a combination of a CODE_PHRASE (effectively a code) and the rubric of that term, from a terminology service, in the language in which the data was authored.

Since CODED_TEXT is a subtype of TEXT, it can be used in place of it, effectively allowing the type TEXT to mean a text item, which may optionally be coded.

Misuse: If the intention is to represent a term code attached in some way to a fragment of plain text, CODED_TEXT should not be used.">
		name = <"CodedText">
		ancestors = <"Text",...>
		properties = <
			["concept"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The identifier of a concept in a terminology.">
				name = <"concept">
				type = <"Concept">
			>
			["mapping"] = (P_BMM_CONTAINER_PROPERTY) <
				documentation = <"Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC).">
				name = <"mapping">
				type_def = <
					container_type = <"List">
					type = <"TermMapping">
				>
				cardinality = <|>=0|>
			>
		>
	>
	["Integer"] = <
		documentation = <"Countable quantities. Used for countable types such as pregnancies and steps (taken by a physiotherapy patient), number of cigarettes smoked in a day.

Misuse: Not to be used for amounts of physical entities (which all have units).">
		name = <"Integer">
		ancestors = <"NumericalValue",...>
		properties = <
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The integer count value.">
				name = <"value">
				type = <"Integer">
				is_mandatory = <True>
			>
		>
	>
	["DataType"] = <
		documentation = <"Serves as a common ancestor of all CIMI complex types.">
		name = <"DataType">
	>
	["Date"] = <
		documentation = <"Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.">
		name = <"Date">
		ancestors = <"TemporalValue",...>
	>
	["TemporalValue"] = <
		documentation = <"Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601.

Used for recording a precise point in real world time, and for approximate time stamps, e.g. the origin of a HISTORY in an OBSERVATION which is only partially known.">
		name = <"TemporalValue">
		ancestors = <"OrderedValue",...>
		properties = <
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"ISO8601 date&#47;time string.">
				name = <"value">
				type = <"String">
				is_mandatory = <True>
			>
		>
	>
	["Duration"] = <
		documentation = <"Represents a period of time with respect to a notional point in time, which is not specified. A sign may be used to indicate the duration is backwards in time rather than forwards.

NOTE
a deviation from ISO8601 is supported, allowing the W' designator to be mixed with other designators. See assumed types section in the Support IM.
Used for recording the duration of something in the real world, particularly when there is a need a) to represent the duration in customary format, i.e. days, hours, minutes etc, and b) if it will be used in computational operations with date&#47;time quantities, i.e. additions, subtractions etc.

Misuse: Durations cannot be used to represent points in time, or intervals of time.">
		name = <"Duration">
		ancestors = <"Quantity",...>
		properties = <
			["durationText"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"ISO8601 duration string.">
				name = <"durationText">
				type = <"String">
			>
		>
	>
	["EmbeddedContent"] = <
		documentation = <"Abstract class defining the common meta-data of all types of encapsulated data.">
		name = <"EmbeddedContent">
		ancestors = <"DataType",...>
	>
	["IntervalValue"] = <
		documentation = <"Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type ORDERED_VALUE, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).

The basic semantics are derived from the class Interval&lt;T&gt;, described in the support RM.">
		name = <"IntervalValue">
		ancestors = <"DataType",...>
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"OrderedValue">
			>
		>
		properties = <
			["lowerIncluded"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"True if the lower bound of the interval is included. False otherwise.">
				name = <"lowerIncluded">
				type = <"Boolean">
				is_mandatory = <True>
			>
			["lowerUnbounded"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"True if the interval does not specify a lower bound. False otherwise.">
				name = <"lowerUnbounded">
				type = <"Boolean">
				is_mandatory = <True>
			>
			["upperIncluded"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"True if the upper bound of the interval is included. Otherwise, false.">
				name = <"upperIncluded">
				type = <"Boolean">
				is_mandatory = <True>
			>
			["upperUnbounded"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"True if the upper bound is unspecified. False otherwise.">
				name = <"upperUnbounded">
				type = <"Boolean">
				is_mandatory = <True>
			>
			["lower"] = (P_BMM_SINGLE_PROPERTY_OPEN) <
				documentation = <"The  interval's lower bound. Values outside the lower bound lie outside the range specified by this interval.">
				name = <"lower">
				type = <"T">
			>
			["upper"] = (P_BMM_SINGLE_PROPERTY_OPEN) <
				documentation = <"The reference range's upper bound. Values outside the upper bound lie outside the  range specified by this interval.">
				name = <"upper">
				type = <"T">
			>
		>
	>
	["Multimedia"] = <
		documentation = <"A specialisation of DV_ENCAPSULATED for audiovisual and biosignal types. Includes further metadata relating to multimedia types which are not applicable to other subtypes of DV_ENCAPSULATED.">
		name = <"Multimedia">
		ancestors = <"EmbeddedContent",...>
		properties = <
			["alternateText"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Text to display in lieu of multimedia display&#47;replay.">
				name = <"alternateText">
				type = <"Byte">
			>
			["data"] = (P_BMM_CONTAINER_PROPERTY) <
				documentation = <"The actual data found at uri, if supplied inline.">
				name = <"data">
				type_def = <
					container_type = <"List">
					type = <"Byte">
				>
				cardinality = <|>=0|>
			>
			["mediaType"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Data media type coded from openEHR code set media types (interface for the IANA MIME types code set).">
				name = <"mediaType">
				type = <"Concept">
				is_mandatory = <True>
			>
			["resourceIdentifier"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"URI reference to electronic information stored outside the record as a file, database entry etc, if supplied as a reference.">
				name = <"resourceIdentifier">
				type = <"Uri">
			>
		>
	>
	["OrdinalConcept"] = <
		documentation = <"Models rankings and scores, e.g. pain, Apgar values, etc, where there is a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite. Note that although the term ordinal' in mathematics means natural numbers only, here any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point. Examples of sets of ordinal values:

-3, -2, -1, 0, 1, 2, 3  — reflex response values
0, 1, 2  — Apgar values
This class is used for recording any clinical datum which is customarily recorded using symbolic values. Example: the results on a urinalysis strip, e.g. {neg, trace, , , } are used for leucocytes, protein, nitrites etc; for non-haemolysed blood {neg, trace, moderate}; for haemolysed blood small, moderate, large}.">
		name = <"OrdinalConcept">
		ancestors = <"Concept",...>
		properties = <
			["positionInSet"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Value in ordered enumeration of values. Any integer value can be used.">
				name = <"positionInSet">
				type = <"Real">
				is_mandatory = <True>
			>
		>
	>
	["ParsableContent"] = <
		documentation = <"Encapsulated data expressed as a parsable String. The internal model of the data item is not described in the openEHR model in common with other encapsulated types, but in this case, the form of the data is assumed to be plaintext, rather than compressed or other types of large binary data.
">
		name = <"ParsableContent">
		ancestors = <"EmbeddedContent",...>
		properties = <
			["formalism"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Name of the formalism, e.g. GLIF 1.0 , Proforma etc.">
				name = <"formalism">
				type = <"Concept">
				is_mandatory = <True>
			>
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The string, which may validly be empty in some syntaxes.">
				name = <"value">
				type = <"String">
				is_mandatory = <True>
			>
		>
	>
	["PlainText"] = <
		documentation = <"Plain text potentially with simple formatting">
		name = <"PlainText">
		ancestors = <"Text",...>
	>
	["OrderedValue"] = <
		documentation = <"Abstract class defining the concept of true quantified values, i.e. values which are not only ordered, but which have a precise magnitude.">
		name = <"OrderedValue">
		ancestors = <"DataType",...>
		properties = <
			["valueStatus"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Optional status of magnitude with values:

= : magnitude is a point value
&lt; : value is &lt; magnitude
&gt; : value is &gt; magnitude
&lt;= : value is &lt;= magnitude
&gt;= : value is &gt;= magnitude
~ : value is approximately magnitude
If not present, meaning is = .">
				name = <"valueStatus">
				type = <"Concept">
			>
		>
	>
	["Quantity"] = <
		documentation = <"Quantitified type representing scientific quantities, i.e. quantities expressed as a magnitude and units. Units were inspired by the Unified Code for Units of Measure (UCUM), developed by Gunther Schadow and Clement J. McDonald of The Regenstrief Institute.

Can also be used for time durations, where it is more convenient to treat these as simply a number of seconds rather than days, months, years.">
		name = <"Quantity">
		ancestors = <"NumericalValue",...>
		properties = <
			["units"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Units, expressed expressed as codes (generally UCUM), e.g. 'kg&#47;m2', “mm[Hg]', 'ms-1', 'km&#47;h'. Implemented accordingly in subtypes.">
				name = <"units">
				type = <"Concept">
				is_mandatory = <True>
			>
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Numeric magnitude of the quantity.

">
				name = <"value">
				type = <"Real">
				is_mandatory = <True>
			>
		>
	>
	["TermMapping"] = <
		documentation = <"Represents a coded term mapped to a TEXT, and the relative match of the target term with respect to the mapped item. Plain or coded text items may appear in the EHR for which one or mappings in alternative terminologies are required. Mappings are only used to enable computer processing, so they can only be instances of CODED_TEXT. Used for adding classification terms (e.g. adding ICD classifiers to SNOMED descriptive terms), or mapping into equivalents in other terminologies (e.g. across nursing vocabularies).">
		name = <"TermMapping">
		properties = <
			["match"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The relative match of the target term with respect to the mapped text item. Result meanings:

'&gt;': the mapping is to a broader term e.g. orginal text = arbovirus infection , target = viral infection
'=': the mapping is to a (supposedly) equivalent to the original item
'&lt;': the mapping is to a narrower term. e.g. original text = diabetes , mapping = diabetes mellitus .
'?': the kind of mapping is unknown.
The first three values are taken from the ISO standards 2788 ( Guide to Establishment and development of monolingual thesauri ) and 5964 ( Guide to Establishment and development of multilingual thesauri ).">
				name = <"match">
				type = <"Concept">
				is_mandatory = <True>
			>
			["purpose"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Purpose of the mapping e.g. automated data mining , billing , interoperability">
				name = <"purpose">
				type = <"Concept">
			>
			["target"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The target term of the mapping.">
				name = <"target">
				type = <"Concept">
				is_mandatory = <True>
			>
		>
	>
	["Text"] = <
		documentation = <"Abstract parent for plain textual and coded text items, which may contain any amount of legal characters arranged as e.g. words, sentences etc (i.e. one Text may be more than one word). Visual formatting and hyperlinks may be included.">
		name = <"Text">
		ancestors = <"DataType",...>
		properties = <
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Displayable rendition of the item, regardless of its underlying structure. For CODED_TEXT, this is the rubric of the complete term as provided by the terminology service. No carriage returns, line feeds, or other non-printing characters permitted.">
				name = <"value">
				type = <"String">
				is_mandatory = <True>
			>
			["language"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"The text's language.">
				name = <"language">
				type = <"Concept">
			>
		>
	>
	["Time"] = <
		documentation = <"Represents an absolute point in time from an origin usually interpreted as meaning the start of the current day, specified to a fraction of a second. Semantics defined by ISO 8601.

Used for recording real world times, rather than scientifically measured fine amounts of time. The partial form is used for approximate times of events and substance administrations.">
		name = <"Time">
		ancestors = <"TemporalValue",...>
	>
	["Uri"] = <
		documentation = <"A reference to an object which conforms to the Universal Resource Identifier (URI) standard. See 'Universal Resource Identifiers in WWW' by Tim Berners-Lee at http:&#47;&#47;www.ietf.org&#47;rfc&#47;rfc3986.txt. This is a World-Wide Web RFC for global identification of resources. See http:&#47;&#47;www.w3.org&#47;Addressing for a starting point on URIs.">
		name = <"Uri">
		ancestors = <"DataType",...>
		properties = <
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Value of URI">
				name = <"value">
				type = <"String">
				is_mandatory = <True>
			>
		>
	>
	["Instant"] = <
		documentation = <"An instant in time - known at least to the second and always includes a time zone. Note: This is intended for precisely observed times (typically system logs etc.), and not human-reported times - for them, use date and dateTime. instant is a more constrained dateTime">
		name = <"Instant">
		ancestors = <"DateTime",...>
	>
	["PositiveInteger"] = <
		documentation = <"An integer whose value is greater than zero.">
		name = <"PositiveInteger">
		ancestors = <"UnsignedInteger",...>
	>
	["UnsignedInteger"] = <
		documentation = <"An integer whose value is greater or equal to zero.">
		name = <"UnsignedInteger">
		ancestors = <"Integer",...>
	>
	["Ratio"] = <
		documentation = <"A parameterizable ratio.">
		name = <"Ratio">
		ancestors = <"DataType",...>
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"NumericalValue">
			>
		>
		properties = <
			["denominator"] = (P_BMM_SINGLE_PROPERTY_OPEN) <
				documentation = <"The denominator of the ratio.">
				name = <"denominator">
				type = <"T">
			>
			["numerator"] = (P_BMM_SINGLE_PROPERTY_OPEN) <
				documentation = <"The numerator of the ratio.">
				name = <"numerator">
				type = <"T">
			>
			["type"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Indicates semantic type of the ratio.">
				name = <"type">
				type = <"Concept">
			>
		>
	>
	["Concept"] = <
		name = <"Concept">
		ancestors = <"DataType",...>
		properties = <
			["code"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"code">
				type = <"String">
				is_mandatory = <True>
			>
			["codeSystem"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"codeSystem">
				type = <"CodeSystem">
				is_mandatory = <True>
			>
			["isExpression"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"isExpression">
				type = <"Boolean">
			>
			["conceptUri"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"conceptUri">
				type = <"Uri">
			>
			["displayTerm"] = (P_BMM_CONTAINER_PROPERTY) <
				documentation = <"The preferred textual rendition of the code attribute.">
				name = <"displayTerm">
				type_def = <
					container_type = <"List">
					type = <"PlainText">
				>
				cardinality = <|>=0|>
			>
		>
	>
	["CodeSystem"] = <
		name = <"CodeSystem">
		ancestors = <"DataType",...>
		properties = <
			["name"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"name">
				type = <"String">
				is_mandatory = <True>
			>
			["version"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"version">
				type = <"String">
				is_mandatory = <True>
			>
			["uri"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"uri">
				type = <"Uri">
			>
		>
	>
	["GpsLocation"] = <
		name = <"GpsLocation">
		ancestors = <"DataType",...>
		properties = <
			["longitude"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Longitude with WGS84 datum">
				name = <"longitude">
				type = <"Real">
				is_mandatory = <True>
			>
			["latitude"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Latitude with WGS84 datum">
				name = <"latitude">
				type = <"Real">
				is_mandatory = <True>
			>
			["altitude"] = (P_BMM_SINGLE_PROPERTY) <
				documentation = <"Altitude with WGS84 datum">
				name = <"altitude">
				type = <"Real">
			>
		>
	>
	["DateTime"] = <
		name = <"DateTime">
		ancestors = <"TemporalValue",...>
	>
	["Decimal"] = <
		name = <"Decimal">
		ancestors = <"NumericalValue",...>
		properties = <
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"value">
				type = <"Real">
				is_mandatory = <True>
			>
		>
	>
>
primitive_types = <
	["Any"] = <
		documentation = <"Abstract supertype. Usually maps to a type like “Any” or “Object” in an object system. Defined here to provide the value and reference equality semantics.">
		name = <"Any">
	>
	["Array"] = <
		documentation = <"physical container of items indexed by number">
		name = <"Array">
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"Any">
			>
		>
	>
	["List"] = <
		documentation = <"container of items, implied order, non-unique membership">
		name = <"List">
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"Any">
			>
		>
	>
	["Boolean"] = <
		documentation = <"logical True&#47;False values; usually physically represented as an integer, but need not be">
		name = <"Boolean">
	>
	["Byte"] = <
		documentation = <"a type whose value is an 8-bit value.">
		name = <"Byte">
	>
	["Character"] = <
		documentation = <"a type whose value is a member of an 8-bit character-set (ISO: 'repertoire').">
		name = <"Character">
	>
	["Integer"] = <
		documentation = <"An integer type">
		name = <"Integer">
	>
	["Real"] = <
		documentation = <"32-bit real numbers in any interoperable representation, including single-width IEEE floating point">
		name = <"Real">
	>
	["String"] = <
		documentation = <"represents unicode-enabled strings">
		name = <"String">
	>
	["URI"] = <
		documentation = <"A URI">
		name = <"URI">
	>
>

